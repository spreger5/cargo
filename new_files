#!/usr/bin/perl
#==============================================================================================
#
# Ab dem aktuellen VZ die Files ermitteln und nach Modifikations-Datum sortieren.
# Git- und Kitchen-Verzeichnisse werden immer ignoriert!
#
#  * Das Debugging ist auch moeglich, wenn in der Umgebung die Variable DEBUG gesetzt ist (egal
#    wie, sie muss nur vorhanden sein).
#
# Achtung: Unter gewissen Umstaenden (z.B gewisse Linux- und MC-Versionen) wird das Ergebnis
#          nicht vollstaendig angezeigt, wenn dieses Programm im MC aufgerufen wird!!!
#
#----------------------------------------------------------------------------------------------
#  Parameter:
#  ----------
#
#     -subdirs|nosubdirs   [kann] ... Unter-VZs werden (nicht) verarbeitet
#
#                          Default: -subdirs
#
#     -fspecre <Spez,...>  [kann] ... zu verarbeitende Dateinamen (ohne Pfad),
#                                     als Perl-RegEx spezifiziert. Mehrere RegExe
#                                     koennen mit Komma voneinander getrennt werden.
#                                     Zudem darf diese Option beliebig oft spezifiziert werden
#                                     Grosz-/Kleinschreibung der RegEx spielt keine Rolle!
#
#                          Default: .+ (d.h. alles. Keine Einschraenkung der Dateinamen)
#                                   Git- und Kitchen-Verzeichnisse werden immer ignoriert!
#
#     -links|nolinks [kann] ... Symlinks werden (nicht) verarbeitet
#
#                          Default: -nolinks
#
#     -help|hilfe|?        [kann] ... Hilfe gewuenscht
#
#     -debug|nodebug       [kann] ... Debug-Infos werden (nicht) zusaetzlich ausgegeben
#
#                          Default: -nodebug
#----------------------------------------------------------------------------------------------
#
#  D-Lib: C:/UtilNT/SFU/apps/util/Spg
#
#  T-Lib: Win32: C:/BatNT
#
#  T-Lib: Unix.: ~/bin   (Verteilung siehe ./new_Files2ZGI.cmd)
#
#----------------------------------------------------------------------------------------------
#  Erstellt von: Gerhard Sprenger
#            am: 20.09.2017
#----------------------------------------------------------------------------------------------
#  Aenderungen: 01. 30.09.2017  Sprenger
#                   Pruefen, ob die stat()-Funktion eine gueltige Modifikationszeit einer
#                   Datei retourniert.
#
#               02. 25.01.2018  Sprenger
#                   Meldungstexte und Kommentare klarer formuliert.
#
#               03. 05.03.2019  Sprenger
#                   Git- und Kitchen-Verzeichnisse immer ignorieren.
#
#               04. 29.11.2020  Sprenger
#                   Mehr Infos ausgeben und Option '-hilfe|-help' ergaenzt.
#----------------------------------------------------------------------------------------------

use strict; use warnings;
use Getopt::Long;
use Data::Dumper;
use Cwd;                   # w/ getcdw()
use File::Find;

#--- Unter Win32 muss die ANSI-Unterstuetzung extra installiert und aktiviert werden ---
if ($^O =~ m/MSWin/i) { require Win32::Console::ANSI; }


# --- ANSI-Farben ----
my $ansiEsc = "\e["; # 0x1B [

my $ansiF_HRoSw = $ansiEsc . '1;31;40m';   # Hellrot auf Schwarz
my $ansiF_HGeSw = $ansiEsc . '1;33;40m';   # Hellgelb auf Schwarz
my $ansiF_HGrSw = $ansiEsc . '1;32;40m';   # Hellgruen auf Schwarz
my $ansiF_HWeSw = $ansiEsc . '1;37;40m';   # Hellweisz auf Schwarz
my $ansiF_NWeSw = $ansiEsc . '0;37;40m';   # Normalweisz auf Schwarz
my $ansiF_NullM =            "\e(U";       # Null Mapping, keine Zeichenkonvertierung

my $ansiScr_Cls   = $ansiEsc . '2J';       # Bildschirm loeschen, Cursorposition bleibt erhalten
my $ansiScr_Home  = $ansiEsc . 'H';        # Cursor links oben positionieren

# ---- Globale Einstellungen -------------------------------------------------------
my %sGblOptions = (  # globale Einstellungen. Anpassung ueber Befehlszeile moeglich
   'subdirs'     =>  1,  # Unterverzeichnisse auch verarbeiten J/N
   'fSpecRE'     =>  [], # zu verarbeitende Files als Perl-RegEx
   'followlinks' =>  0,
   'help'        =>  0,
   'debug'       =>  0,
                  );
my $bDebug;
my $bFollowLinks;   # Symlinks beruecksichtigen J/N
my $bHelpWanted;

my $sHostname = qx(hostname); chomp $sHostname;
my $bOutputRedirected = -t STDOUT ? 0 : 1;

my $fDirAkt    = Cwd::getcwd;       # absoluter Pfad des akt. Arbeitsverzeichnisses in Unix-Notation
my $iDirAktLng = length($fDirAkt);

my @fInclFilesRE;                   # RegEx-Filenamen (die verarbeitet werden) aus den Befehlszeilenparametern

my @AktFiles;                       # Files, deren CRCs berechnet werden
my $cAnzFiles  = 0;
my $cAnzErrors = 0;                 # Anzahl Files, die nicht verarbeitet werden koennen (z.B. Mod-Zeit ist UNDEF)

my $iProgressBlksize = 500;         # nach jeweils so vielen verarbeiteten Dateien eine Fortschrittsmeldung ausgeben (StdErr)

   # --- Groeszen fuer Datum und Zeit -------------------------------------------
my $tJetztStart;                    # Aktuelle Start-Zeit in Epochensekunden
my $tJetztEnde;                     # Aktuelle Ende-Zeit in Epochensekunden

my ($tJetztTag,   $tJetztMon,   $tJetztJhrJJJJ);
my ($tJetztSek,   $tJetztMin,   $tJetztStd);

   #--- Hilfsvariablen ---

my ($i, $j, $farbe, $x1, $x2, $x3, $sShellCmd, $xxx);

   #--- Fallback-Routinen zu 'File::Find' ---

   # FileFindFallback
   # ----------------
   #
   # Dateien ab einem bestimmten Startverzeichnis ermitteln, deren Name (ohne dem Pfad) einer RegEx entspricht.
   # Je Datei wird deren Modifikationszeit in Epochensekunden und der FQN in einem globalen Array abgelegt.
   #
   # Erklaerung einiger Variablen etc.
   #
   #                $File::Find::name  $File::Find::dir  $_
   #   default      /                  /                 .
   #   no_chdir=>0  /etc               /                 etc
   #                /etc/x             /etc              x
   #
   #   no_chdir=>1  /                  /                 /
   #                /etc               /                 /etc
   #                /etc/x             /etc              /etc/x


sub GetAllFiles {

   # Dateien fuer vorgegebenes Muster ab Startverzeichnis ermitteln.
   # Verzeichnisse werden ignoriert.
   #
   # Globale Groeszen: W - @AktFiles      ... Ergebnis dieser Fallback-Routine
   #                   R - %sGblOptions   ... globale Optionen
   #                   R - $fDirAkt       ... Start-VZ fuer die Filesuche (FQN in Unix-Notation)
   #                   R - @fInclFilesRE  ... zu verarbeitende Files als RegEx

   my $sFqn = $File::Find::name;                # voll qualifizierter DSN
   my $sDir = $File::Find::dir;                 # voll qualifiziertes Verzeichnis
   my $sFn;                                     # reiner Dateiname (ohne Verzeichnis)
   my $iModTs;                                  # Modifikationszeit in Epochensekunden

   # print Dumper($sDir, $sFqn);
   # print "Is-Dir: ", (-d $sFqn ? 'ja' : 'nein'), "\n";
   # print "Is-Lnk: ", (-l $sFqn ? 'ja' : 'nein'), "\n";

   return if -d $sFqn;                          # Verzeichnisse *nicht* verarbeiten

#  Die ev. Verarbeitung von Symlinks wird bereits beim Aufruf von 'find' gesteuert. Sie hat deshalb
#  an dieser Stelle keine Bedeutung mehr. Sonst koennte man Symlinks wie folgt ignorieren:
#
#     return if -l $sFqn;

   # Hinweis: '$File::Find::name' liefert keine Eintraege '.' und '..'

   if (! $sGblOptions{'subdirs'}) {
      return if lc($sDir) ne lc($fDirAkt);      # Unter-VZ ignorieren
   }

   # Git- und Kitchen-Verzeichnisse immer ignorieren (enthalten '/.git' oder '/.kitchen')

#  print "sDir >$sDir<\n";
   if ($sDir =~ /\x2F \.(git|kitchen) (\x2F|$)/ix) {    # .../.git/..., .../.git        0x2F == '/'
#     print "match!\n";
      return;
   }

   # Pruefen, ob die Datei gewuenscht ist. Es werden alle Filespezifikationen (RegEx) geprueft, wenn
   # eine zutrifft, werden keine weiteren geprueft, damit keine Mehrfacheintraege erzeugt werden.

   $sFn = substr($sFqn, length($sDir)+1);       # reiner Dateiname (ohne Verzeichnis)

   foreach my $fIncl (@fInclFilesRE) {
      if ($sFn =~ m/$fIncl/i) {

         ($iModTs) = (stat($sFn))[9];

         # Die Modifikationszeiten sind seit Laengerem 10 Ziffern breit, wobei sie mit '1' beginnen.
         # Sie werden rechtsbuendig mit 11 Ziffern aufbereitet, damit 'aeltere' als auch zukuenftige
         # Modifikationszeiten "sauber" sortiert werden koennen.

         # Manche Perl-Versionen haben Probleme, die Modifikationszeit festzustellen, vor allem
         # dann, wenn die Datei "ungewoehnliche" Zeichen enthaelt. Meistens gibt dann obige
         # stat()-Funktion UNDEF zurueck.

         if (!defined($iModTs)) {
            print "Modifikationszeit ist UNDEF fuer >$sFqn<. Datei wird ignoriert!\n";
            $cAnzErrors++;
         }
         elsif ($iModTs !~ m/^ \d+ $/x) {
            print "Modifikationszeit >$iModTs< ist nicht numerisch fuer >$sFqn<. Datei wird ignoriert!\n";
            $cAnzErrors++;
         }
         else {
            push @AktFiles, Right($iModTs, 11)  . ' ' . $sFqn;
            last;   # Mehrfacheintraege vermeiden
         }
      }
   }

   return;
}

#-----------------------------------------------------------------------------------
#---   Operationaler Verarbeitungsteil   -------------------------------------------
#-----------------------------------------------------------------------------------

 ($tJetztStart, $tJetztSek, $tJetztMin, $tJetztStd, $tJetztTag, $tJetztMon, $tJetztJhrJJJJ) = GetActTimeItems();

 GetOptions(
            'subdirs!'       => \$sGblOptions{'subdirs'},
            'fspecre:s'      => \@{$sGblOptions{'fSpecRE'}},  # zu verarbeitende Files als RegEx
            'links!'         => \$sGblOptions{'followlinks'},
            'help|?|hilfe!'  => \$sGblOptions{'help'},
            'debug|verbose!' => \$sGblOptions{'debug'},
           );

 $bDebug = $sGblOptions{'debug'};
 if (defined($ENV{'DEBUG'})) {
    $bDebug = 1;
 }

 @fInclFilesRE = @{$sGblOptions{'fSpecRE'}};
 $bFollowLinks = $sGblOptions{'followlinks'};
 $bHelpWanted  = $sGblOptions{'help'};

 PrintGblOptions() if $bDebug;  # Rohwerte (d.h. 1:1) der Optionen ex Befehlszeile ausgeben

 if ($bHelpWanted) {
    print "\nDie Hilfe ist noch nicht implementiert!!!\n\n";
    ShowUsage();
    exit 4;
 }

 #--- 'RegEx'-Dateinamen Array-maeszig normieren ('gleichmaeszig auffaedeln'). D.h. ein Array generieren,
 #    das je Element/Zeile *einen* einzigen Namen enthaelt.
 #    Sollte das Array leer sein, dann mit dem Defaultwert (.+ == beliebiger Name) fuellen.

 if (!@fInclFilesRE) {
    push @fInclFilesRE, '.+';
 }
 else {
    @fInclFilesRE = split(/,/, join(',', @fInclFilesRE));    # gleichmaeszig auffaedeln
    s/^ \s* | \s* $//gx foreach @fInclFilesRE;               # fuehrende und endende Blanks entfernen
 }

 if ($bDebug) {
    print "\nRegExen der zu inkludierenden Files am Programmstart:\n";

    foreach my $f (@fInclFilesRE) {
       print "   >", $f, "<\n";
    }

    print "\n";
 }


 # Array '@AktFiles' einrichten. Alle Files ab dem akt. Verzeichnis, voll qualifiziert und in Unix-Notation.
 # Ihre Namen (ohne Pfad) muessen einer RegEx entsprechen. Zudem wird deren Modifikationszeit gespeichert.

 # Typisches Ergebnis:
 # ===================
 #
 #               1         2
 #     012345678901234567890
 #
 #    ' 1504689868 D:/Tmp/Z23/arz_travic_corporate/attributes/default.rb'
 #    ' 1504689870 D:/Tmp/Z23/arz_travic_corporate/recipes/default.rb'
 #    ' 1504689870 D:/Tmp/Z23/arz_travic_corporate/spec/unit/recipes/default_spec.rb'
 #    ' 1504689870 D:/Tmp/Z23/arz_travic_corporate/test/integration/default/serverspec/default_spec.rb'

 find ({ wanted => \&GetAllFiles, follow => $bFollowLinks }, $fDirAkt);

 if ($bDebug) {
    if (@AktFiles == 0) {
       $x1 = "   <keine>\n";
    }
    else {
       $x1 = join('', map {"  '$_'\n"} @AktFiles);
    }

    $xxx = "Folgende *Dateien* lt. Filespezifikation wurden in '$fDirAkt' gefunden (ohne Git/Kitchen):\n\n" . $x1;
    print $xxx;
 }

 # Array '@AktFiles' sortieren. Durch den Aufbau der Zeilen wird zuerst nach der Modifikationszeit,
 # dann nach dem FQN sortiert.

 @AktFiles = sort @AktFiles;

 if ($bDebug) {
    print "\nDie Dateien nach der Sortierung nach Modifikationszeit und FQN:\n\n";
    print Dumper(\@AktFiles), "\n\n";
 }

 # Ausgabe

 print "\n# Dateien lt. RegEx(en) '", join(', ', @fInclFilesRE), "' in Verzeichnis '$fDirAkt' nach Modifikations-Datum sortiert,",
       "\n# Verzeichnisse '/.git' und '/.kitchen' werden ignoriert.",
       "\n# Unterverzeichnisse werden ", $sGblOptions{'subdirs'} ? "" : "nicht ", "beruecksichtigt.",
       "\n# Symlinks werden ", $bFollowLinks ? "" : "nicht ", "beruecksichtigt.",
       "\n# Laufdatum: ", FormatDateTime($tJetztStart, 'Dt'), "\n\n";

 $x1 = length($fDirAkt)+1;

 foreach my $zle (@AktFiles) {

    my $ts  = substr($zle, 0, 11);
    my $fqn = substr($zle, 12);

    print '   ', FormatDateTime($ts, 'dt'), ' ',        # '11.05.2014 10:49:15'
          substr($fqn, $x1), "\n";

 }

 if ($cAnzErrors > 0) {
    print $ansiF_HRoSw, "\n",
          "Achtung: $cAnzErrors Datei(en) konnten nicht verarbeitet werden (siehe Beginn der Ausgabeanzeige)!",
          $ansiF_NWeSw, "\n";
 }

 exit 0;

#-----------------------------------------------------------------------------------
#---   Subroutinen und Funktionen   ------------------------------------------------
#-----------------------------------------------------------------------------------

 #-----------------------------------------------------------------------------------
 # Name: GetActTimeItems()
 #
 # Zweck: Die aktuellen Zeit-Werte fuer Jahr, Monat, Tag, Stunde, Minute, Sekunde und
 #        Epochensekunden ermitteln und in einzelnen Skalaren als Liste retournieren.
 #        Die Werte fuer Monat sind 1- 12, jene fuer das Jahr in der Form JJJJ.
 #
 # Parameter: keine
 #
 # Interne Routinen: keine
 #
 # Globale Groeszen: keine
 #
 # Ergebnis: Aktuelle Zeitwerte als Liste von Skalaren (Reihenfolge siehe return-Anweisung)
 #-----------------------------------------------------------------------------------

sub GetActTimeItems {

 my ($t, $tSek, $tMin, $tStd, $tTag, $tMon, $tJhr);

  $t = time;               # aktuelle Zeit in Epochensekunden
  ($tSek, $tMin, $tStd, $tTag, $tMon, $tJhr) = (localtime($t))[0..5];

  $tMon += 1;
  $tJhr += 1900;

  return ($t, $tSek, $tMin, $tStd, $tTag, $tMon, $tJhr);

}

 #----------------------------------------------------------------------------------#

 #-----------------------------------------------------------------------------------
 # Name: PrintGblOptions()
 #
 # Zweck: Die aktuellen Werte der Keys des globalen Optionen-Hashes ausgeben.
 #
 #        Diese Routine sollte zu Programmbeginn direkt nach dem Entgegennehmen
 #        der Optionen ex Befehlszeile mittels Funktion GetOptions()
 #        aufgerufen werden.
 #
 # Parameter: keine
 #
 # Interne Routinen: keine
 #
 # Globale Groeszen: Zugriffe R=Lesen, W=Schreiben, U=Aktualisieren
 #
 #         R - %sGblOptions ... Hash mit den globalen Optionen ex Befehlszeile,
 #                              die via Funktion GetOptions() abgeholt wurden
 #
 #         R - @ARGV        ... Befehlszeilenargumente an das Perl-Programm
 #
 # Ergebnis: 1 (immer)
 #-----------------------------------------------------------------------------------

sub PrintGblOptions {

 my $iMaxOptLng = 1;        # max. Laenge der Namen der Optionen-Keys

  printf "\n%s\n\n", 'Optionen, wie sie 1:1 aus der Befehlszeile uebernommen oder defaultet wurden:';

  #--- Zur "optischen" Aufbereitung wird die max. Laenge der Namen der Optionen-Keys ermittelt
  foreach my $k (keys %sGblOptions) {
     my $l = length($k);
     $iMaxOptLng = $l if $l > $iMaxOptLng;
  }

  #--- Key-Namen und deren Werte ausgeben. Der Wert darf auch ein Array[-Pointer] sein
  foreach my $k (sort {lc($a) cmp lc($b)} keys %sGblOptions) {      # Key-Namen lexikographisch sortiert

     if (ref($sGblOptions{$k}) =~ m/ARRAY/i) {
        my $aPtr = $sGblOptions{$k};

        printf "   %-${iMaxOptLng}s ist: %d Elemente\n", $k, scalar(@$aPtr);

        foreach my $i (0 .. @$aPtr-1) {
           printf "      %2d. >%s<\n", $i+1, $aPtr->[$i];
        }
     }
     else {
        printf "   %-${iMaxOptLng}s ist: >%s<\n", $k, $sGblOptions{$k};
     }
  }
  print "\n";

  #--- Ev. Rest in @ARGV[], der nach Aufruf von GetOptions() noch darin enthalten ist

  if (@ARGV) {
     print "   In ARGV[] verbleibender Inhalt, nachdem die Argumente via GetOptions() abgeholt wurden:\n";
     print "      >$_<\n" foreach @ARGV;
     print "\n";
  }

  return 1;

}

 #----------------------------------------------------------------------------------#

 #-----------------------------------------------------------------------------------
 # Name: ShowUsage()
 #
 # Zweck: Verwendungshinweise anzeigen
 #
 # Parameter: keine
 #
 # Interne Routinen: keine
 #
 # Globale Groeszen: keine
 #
 # Ergebnis: 1 (immer)
 #-----------------------------------------------------------------------------------

sub ShowUsage {

 my $txt;

  ($txt = <<"_______LAB1") =~ s/^[ \t]+//gm;
     @{['=' x 102]}

     new_files. Ab dem aktuellen Verzeichnis die Files ermitteln und nach Modifikations-Datum sortieren.
     æ          Git- und Kitchen-Verzeichnisse werden immer ignoriert!

     Verwendung: new_files [OPTIONEN]...

     æ  -subdirs|nosubdirs   [kann] ... Unter-Verzeichnisse werden (nicht) verarbeitet

     æ                       Default: -subdirs

     æ  -fspecre <Spez,...>  [kann] ... zu verarbeitende Dateinamen (ohne Pfad),
     æ                                  als Perl-RegEx spezifiziert. Mehrere RegExe
     æ                                  koennen mit Komma voneinander getrennt werden.
     æ                                  Zudem darf diese Option beliebig oft spezifiziert werden
     æ                                  Grosz-/Kleinschreibung der RegEx spielt keine Rolle!

     æ                       Default: .+ (d.h. alles. Keine Einschraenkung der Dateinamen)
     æ                                Git- und Kitchen-Verzeichnisse werden immer ignoriert!

     æ  -links|nolinks [kann] ... Symlinks werden (nicht) verarbeitet

     æ                       Default: -nolinks

     new_files wurde *nicht* ausgefuehrt!

     @{['=' x 102]}
_______LAB1

  $txt =~ s/æ/ /g;
  print $txt;

  return 1;

}

 #----------------------------------------------------------------------------------#

 #-----------------------------------------------------------------------------------
 # Name: FormatDateTime()
 #
 # Zweck: Epochensekunden (1. Parameter) je nach Parameter '$sTyp' aufbereiten.
 #        Jede einzelne Stelle von '$sTyp' beschreibt eine Aufbereitung,
 #        es werden alle aufbereiteten Teilergebnisse (mit Blank getrennt)
 #        aneinander gereiht retourniert.
 #
 # Parameter: 1. '$tES'  ... Zeitpunkt in Epochensekunden
 #            2. '$sTyp' ... gewuenschte Aufbereitung 'D' -> JJJJ-MM-TT
 #                                                    'd' -> TT.MM.JJJJ
 #                                                    't' -> HH:MM:SS
 #                                                    'E' -> JJJJ:MM:TT HH:MM:SS (Exif-konform)
 #
 #               !!! beliebige Kombinationen der Werte 'D', 'd', 't' und 'E' sind erlaubt !!!
 #
 # Interne Routinen: keine
 #
 # Benoetigte Module: keine
 #
 # Beispiele: FormatDateTime(time(), 'Dt')   ===> '2006-05-11 10:49:15'
 #            FormatDateTime(time(), 'Dtd')  ===> '2006-05-11 10:49:15 11.05.2006'
 #            FormatDateTime(time(), 't')    ===> '10:49:15'
 #            FormatDateTime(time(), 'd')    ===> '11.05.2006'
 #            FormatDateTime(time(), 'E')    ===> '2007:12:29 09:28:12'
 #
 # Globale Groeszen: keine
 #
 # Ergebnis: aufbereiteter Zeitpunkt.
 #-----------------------------------------------------------------------------------

sub FormatDateTime {

 my $tES  = $_[0];                     # umzuwandelnder Zeitpunkt in Epochensekunden
 my $sTyp = $_[1];                     # gewuenschte Aufbereitungen

 my ($sErg, $sTmp, $c);
 my ($tSS, $tMM, $tHH, $tTag, $tMon, $tJhr) = (localtime($tES))[0..5]; $tMon += 1; $tJhr += 1900;

 $sTyp = 'dt' if ! defined($sTyp);

  foreach my $ix (0..length($sTyp)-1) {
     $c = substr($sTyp, $ix, 1);

     if    ($c =~ /D/) {
        $sTmp = sprintf "%04d-%02d-%02d", $tJhr, $tMon, $tTag;    # JJJJ-MM-TT
     }
     elsif ($c =~ /d/) {
        $sTmp = sprintf "%02d.%02d.%04d", $tTag, $tMon, $tJhr;    # TT.MM.JJJJ
     }
     elsif ($c =~ /t/) {
        $sTmp = sprintf "%02d:%02d:%02d", $tHH,  $tMM,  $tSS;     # HH:MM:SS
     }
     elsif ($c =~ /E/) {
        $sTmp = sprintf "%04d:%02d:%02d %02d:%02d:%02d", $tJhr, $tMon, $tTag, $tHH, $tMM, $tSS; # JJJJ:MM:TT HH:MM:SS
     }
     else {
        $sTmp = '';
     }

     $sErg .= $ix>0 ? " $sTmp" : $sTmp;
  }

  return $sErg;

}

 #----------------------------------------------------------------------------------#

 #-----------------------------------------------------------------------------------
 # Name: Right()
 #
 # Zweck: REXX-Funktion Right() simulieren.
 #
 # Parameter: 1. 'kette' ... Zeichenkette
 #            2. 'lng'   ... Laenge des Resultats
 #
 # Interne Routinen: keine
 #
 # Benoetigte Module: keine
 #
 # Globale Groeszen: keine
 #
 # Ergebnis: Die letzten 'lng' Zeichen der Zeichenkette 'kette', ggf. mit Blanks
 #           links ergaenzt.
 #-----------------------------------------------------------------------------------

sub Right {

 my ($kette, $lng) = @_;

  $kette = (' ' x $lng) . $kette;
  return substr($kette, length($kette)-$lng);

}

 #----------------------------------------------------------------------------------#

